-- =============================================
-- Gestion des Produits Extra - Taxi-brousse
-- =============================================
-- Fonctionnalité: Vente de produits (boissons, snacks, etc.) aux passagers
-- =============================================

SET client_encoding = 'UTF8';

BEGIN;

-- ---------- Nettoyage ----------
DROP TABLE IF EXISTS vente_produit CASCADE;
DROP TABLE IF EXISTS stock_depart CASCADE;
DROP TABLE IF EXISTS produit CASCADE;
DROP TABLE IF EXISTS ref_categorie_produit CASCADE;

-- ---------- Table de référence : Catégories de produits ----------
CREATE TABLE ref_categorie_produit (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code VARCHAR(30) NOT NULL UNIQUE,
    libelle VARCHAR(80) NOT NULL,
    description TEXT,
    actif BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

COMMENT ON TABLE ref_categorie_produit IS 'Catégories de produits (boissons, snacks, etc.)';

-- ---------- Catalogue de produits ----------
CREATE TABLE produit (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code VARCHAR(80) NOT NULL UNIQUE,
    nom VARCHAR(200) NOT NULL,
    description TEXT,
    ref_categorie_produit_id BIGINT NOT NULL,
    ref_devise_id BIGINT NOT NULL,
    prix_vente DECIMAL(12,2) NOT NULL CHECK (prix_vente >= 0),
    actif BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_produit_categorie FOREIGN KEY (ref_categorie_produit_id) REFERENCES ref_categorie_produit(id),
    CONSTRAINT fk_produit_devise FOREIGN KEY (ref_devise_id) REFERENCES ref_devise(id)
);

COMMENT ON TABLE produit IS 'Catalogue des produits disponibles à la vente';
COMMENT ON COLUMN produit.prix_vente IS 'Prix de vente au client';


-- ---------- Stock par départ ----------
CREATE TABLE stock_depart (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    depart_id BIGINT NOT NULL,
    produit_id BIGINT NOT NULL,
    quantite_initiale INTEGER NOT NULL CHECK (quantite_initiale >= 0),
    quantite_vendue INTEGER NOT NULL DEFAULT 0 CHECK (quantite_vendue >= 0),
    quantite_disponible INTEGER NOT NULL CHECK (quantite_disponible >= 0),
    prix_unitaire DECIMAL(12,2) NOT NULL CHECK (prix_unitaire >= 0),
    ref_devise_id BIGINT NOT NULL,
    notes TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_stock_depart_depart FOREIGN KEY (depart_id) REFERENCES depart(id) ON DELETE CASCADE,
    CONSTRAINT fk_stock_depart_produit FOREIGN KEY (produit_id) REFERENCES produit(id) ON DELETE CASCADE,
    CONSTRAINT fk_stock_depart_devise FOREIGN KEY (ref_devise_id) REFERENCES ref_devise(id),
    CONSTRAINT uq_stock_depart UNIQUE (depart_id, produit_id),
    CONSTRAINT ck_stock_coherence CHECK (quantite_disponible = quantite_initiale - quantite_vendue)
);

COMMENT ON TABLE stock_depart IS 'Stock de produits disponible pour chaque départ';
COMMENT ON COLUMN stock_depart.quantite_disponible IS 'Calculé : quantite_initiale - quantite_vendue';

-- ---------- Ventes de produits ----------
CREATE TABLE vente_produit (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    stock_depart_id BIGINT NOT NULL,
    client_id BIGINT,
    quantite INTEGER NOT NULL CHECK (quantite > 0),
    prix_unitaire DECIMAL(12,2) NOT NULL CHECK (prix_unitaire >= 0),
    montant_total DECIMAL(12,2) NOT NULL CHECK (montant_total >= 0),
    ref_devise_id BIGINT NOT NULL,
    date_vente TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    notes TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_vente_stock FOREIGN KEY (stock_depart_id) REFERENCES stock_depart(id) ON DELETE CASCADE,
    CONSTRAINT fk_vente_client FOREIGN KEY (client_id) REFERENCES client(id) ON DELETE SET NULL,
    CONSTRAINT fk_vente_devise FOREIGN KEY (ref_devise_id) REFERENCES ref_devise(id),
    CONSTRAINT ck_vente_montant CHECK (montant_total = quantite * prix_unitaire)
);

COMMENT ON TABLE vente_produit IS 'Enregistrement des ventes de produits aux passagers (liées au départ via stock_depart)';
COMMENT ON COLUMN vente_produit.client_id IS 'Client acheteur (optionnel)';

-- ---------- Index pour performance ----------
CREATE INDEX idx_produit_categorie ON produit(ref_categorie_produit_id) WHERE actif = TRUE;
CREATE INDEX idx_stock_depart_depart ON stock_depart(depart_id);
CREATE INDEX idx_stock_depart_produit ON stock_depart(produit_id);
CREATE INDEX idx_vente_produit_stock ON vente_produit(stock_depart_id);
CREATE INDEX idx_vente_produit_date ON vente_produit(date_vente);
CREATE INDEX idx_vente_produit_client ON vente_produit(client_id) WHERE client_id IS NOT NULL;

-- ---------- Trigger : Mise à jour automatique du stock ----------
CREATE OR REPLACE FUNCTION fn_update_stock_after_vente()
RETURNS TRIGGER AS $$
BEGIN
    -- Mettre à jour les quantités dans stock_depart
    UPDATE stock_depart
    SET quantite_vendue = quantite_vendue + NEW.quantite,
        quantite_disponible = quantite_disponible - NEW.quantite
    WHERE id = NEW.stock_depart_id;
    
    -- Vérifier que le stock ne devient pas négatif
    IF (SELECT quantite_disponible FROM stock_depart WHERE id = NEW.stock_depart_id) < 0 THEN
        RAISE EXCEPTION 'Stock insuffisant pour le produit';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_stock_after_vente
AFTER INSERT ON vente_produit
FOR EACH ROW
EXECUTE FUNCTION fn_update_stock_after_vente();

COMMENT ON FUNCTION fn_update_stock_after_vente IS 'Met à jour automatiquement le stock après une vente';

-- ---------- Trigger : Annulation de vente (remise en stock) ----------
CREATE OR REPLACE FUNCTION fn_restore_stock_after_delete()
RETURNS TRIGGER AS $$
BEGIN
    -- Remettre les quantités dans le stock
    UPDATE stock_depart
    SET quantite_vendue = quantite_vendue - OLD.quantite,
        quantite_disponible = quantite_disponible + OLD.quantite
    WHERE id = OLD.stock_depart_id;
    
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_restore_stock_after_delete
AFTER DELETE ON vente_produit
FOR EACH ROW
EXECUTE FUNCTION fn_restore_stock_after_delete();

COMMENT ON FUNCTION fn_restore_stock_after_delete IS 'Remet le produit en stock après annulation d''une vente';

-- ---------- Données initiales ----------

-- Catégories de produits
INSERT INTO ref_categorie_produit (code, libelle, description, actif) VALUES
('BOISSON_CHAUDE', 'Boissons chaudes', 'Café, thé, chocolat chaud, etc.', TRUE),
('BOISSON_FROIDE', 'Boissons froides', 'Eau, jus, sodas, etc.', TRUE),
('SNACK_SALE', 'Snacks salés', 'Chips, cacahuètes, biscuits salés, etc.', TRUE),
('SNACK_SUCRE', 'Snacks sucrés', 'Bonbons, chocolats, gâteaux, etc.', TRUE),
('REPAS', 'Repas', 'Sandwichs, plats préparés, etc.', TRUE),
('AUTRE', 'Autres produits', 'Produits divers', TRUE)
ON CONFLICT (code) DO NOTHING;

-- Produits exemples
INSERT INTO produit (code, nom, description, ref_categorie_produit_id, ref_devise_id, prix_vente, actif) VALUES
('PROD-001', 'Eau minérale 50cl', 'Eau minérale naturelle', 
    (SELECT id FROM ref_categorie_produit WHERE code = 'BOISSON_FROIDE'), 
    (SELECT id FROM ref_devise WHERE code = 'MGA'), 
    5000.00, TRUE);

COMMIT;

-- ---------- Requêtes de vérification ----------
SELECT 'Catégories de produits créées:', COUNT(*) FROM ref_categorie_produit;
SELECT 'Produits créés:', COUNT(*) FROM produit;

-- ---------- Vue utile : Stock disponible par départ ----------
CREATE OR REPLACE VIEW v_stock_disponible AS
SELECT 
    sd.id,
    d.code AS depart_code,
    d.date_heure_depart,
    p.code AS produit_code,
    p.nom AS produit_nom,
    c.libelle AS categorie,
    sd.quantite_initiale,
    sd.quantite_vendue,
    sd.quantite_disponible,
    sd.prix_unitaire,
    dev.code AS devise,
    sd.quantite_disponible * sd.prix_unitaire AS valeur_stock_disponible
FROM stock_depart sd
JOIN depart d ON sd.depart_id = d.id
JOIN produit p ON sd.produit_id = p.id
JOIN ref_categorie_produit c ON p.ref_categorie_produit_id = c.id
JOIN ref_devise dev ON sd.ref_devise_id = dev.id
ORDER BY d.date_heure_depart DESC, p.nom;

-- ---------- Vue utile : CA produits par départ ----------
CREATE OR REPLACE VIEW v_ca_produits_depart AS
SELECT 
    d.id AS depart_id,
    d.code AS depart_code,
    d.date_heure_depart,
    t.libelle AS trajet,
    COUNT(vp.id) AS nombre_ventes,
    SUM(vp.quantite) AS quantite_totale_vendue,
    SUM(vp.montant_total) AS ca_total,
    dev.code AS devise
FROM depart d
LEFT JOIN vente_produit vp ON vp.stock_depart_id IN (SELECT id FROM stock_depart WHERE depart_id = d.id)
LEFT JOIN trajet t ON d.trajet_id = t.id
LEFT JOIN ref_devise dev ON dev.code = 'MGA'
GROUP BY d.id, d.code, d.date_heure_depart, t.libelle, dev.code
ORDER BY d.date_heure_depart DESC;


